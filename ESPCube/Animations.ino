extern int currentAnimationStep;
extern int currentAnimationMaxSteps;

void turnCubeOff() {
  currentAnimationMaxSteps = 1;
  byte fr0[] = { 0xF2,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
               };

  for (int i = 0; i < 65; i++)
    Serial.write(fr0[i]);
}

void turnCubeFullOn() {
  currentAnimationMaxSteps = 1;
  byte fr0[] = { 0xF2,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
               };

  for (int i = 0; i < 65; i++)
    Serial.write(fr0[i]);
}


void rotateTower(bool left) {
  currentAnimationMaxSteps = 4;
  byte frames[][65] = {
    { 0xF2,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0,
      0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0
    },
    { 0xF2,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
      0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00
    },

    { 0xF2,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
      0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00
    },

    { 0xF2,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F,
      0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F
    }
  };

  if (left) {
    delay(300);

    for (int i = 0; i < 65; i++)
      Serial.write(frames[currentAnimationStep][i]);
  }
  else
  {
    delay(300);

    for (int i = 0; i < 65; i++)
      Serial.write(frames[abs(currentAnimationStep - 3)][i]);
  }
}


void doWave() {
  byte wave[] = {
  
  0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x40, 
  0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x40, 0x20, 
  0x10, 0x20, 0x40, 0x80, 0x80, 0x40, 0x20, 0x10, 
  0x20, 0x40, 0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 
  0x40, 0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 
  0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 
  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
  
  0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 
  0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 0x02, 
  0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 0x02, 0x04, 
  0x08, 0x04, 0x02, 0x01, 0x01, 0x02, 0x04, 0x08,
  0x04, 0x02, 0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 
  0x02, 0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
  0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 
  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 
  0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 
  0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x40, 
  0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x40, 0x20, 
  0x10, 0x20, 0x40, 0x80, 0x80, 0x40, 0x20, 0x10, 
  0x20, 0x40, 0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 
  0x40, 0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 
  0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 
  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
 
  0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 
  0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 
  0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 
  0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };
  currentAnimationMaxSteps = 16;
  int s = (16-currentAnimationStep+7)*8 - 1;
  int e = s - 64;
  Serial.write(0xF2);
  for (int i=s; i>e; i--) {
    Serial.write(wave[i]);
  }
}


void doRandom() {
  Serial.write(0xF2);
  for (int i = 0; i < 64; i++) {
    Serial.write((byte) random(0, 0xFF));
  }
  delay(random(1,1000));
}

void doTest() {
  currentAnimationMaxSteps = 40;
  byte frame[] = {
    0xf2,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

  for (int i = 0; i < 65; i++)
    Serial.write(frame[i]);  frame[1] = 2;
}

void doBinaryFront() {
  currentAnimationMaxSteps = 256;
  byte frame[] = {
    0xf2,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  for (int i = 1; i < 65; i += 8)
    frame[i] += currentAnimationStep;

  for (int i = 0; i < 65; i++)
    Serial.write(frame[i]);
}

void doFence() {
  currentAnimationMaxSteps = 28;
  byte frame[] = {
    0xf2,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  if (currentAnimationStep < 7)
    for (int i = 1; i < 65; i += 8)
      frame[i] = (byte) pow(2, currentAnimationStep);

  else if (currentAnimationStep < 14)
    for (int i = 2 + (currentAnimationStep - 8); i < 65; i += 8)
      frame[i] = 128;

  else if (currentAnimationStep < 21)
    for (int i = 8; i < 65; i += 8)
      frame[i] = (byte) 128 / pow(2, currentAnimationStep - 14);

  else if (currentAnimationStep < 28)
    for (int i = 8 - (currentAnimationStep - 21); i > 0; i -= 8)
      for (int j = 0; j < 8; j++)
        frame[i + 8 * j] = 1;

  for (int i = 0; i < 65; i++)
    Serial.write(frame[i]);
}

void doSignalLight() {
  currentAnimationMaxSteps = 2;
  //60/80/250
  byte frameRight[] = { 0xf2,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
                        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F
                      };

  byte frameLeft[] = { 0xf2,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
                       0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0
                     };

  byte frameOff[] = { 0xf2,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
                    };
  if (currentAnimationStep == 0) {
    for (int i = 0; i < 65; i++)
      Serial.write(frameRight[i]);
    delay(random(50,90));
    for (int i = 0; i < 65; i++)
      Serial.write(frameOff[i]);
    delay(80);
    for (int i = 0; i < 65; i++)
      Serial.write(frameRight[i]);
    delay(60);
    for (int i = 0; i < 65; i++)
      Serial.write(frameOff[i]);
    delay(random(100,300));
  }
  else {
    for (int i = 0; i < 65; i++)
      Serial.write(frameLeft[i]);
    delay(random(50,90));
    for (int i = 0; i < 65; i++)
      Serial.write(frameOff[i]);
    delay(80);
    for (int i = 0; i < 65; i++)
      Serial.write(frameLeft[i]);
    delay(60);
    for (int i = 0; i < 65; i++)
      Serial.write(frameOff[i]);
    delay(random(100,300));
  }
}

byte raindrops[64] = {
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
  };

void doRain(int maxRaindropsPerLevel, int rainDelay) {
  // Step 1: generate ramdon 8*8 rain for new level
  byte level[][8] {
      {0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0}
      };
  if (maxRaindropsPerLevel <= 0) {
    maxRaindropsPerLevel = 1;
  } else if (maxRaindropsPerLevel >= 64) {
    maxRaindropsPerLevel = 63;
  }
  int n = 0, maxDrops = maxRaindropsPerLevel, val = 1;
  if (maxRaindropsPerLevel > 32) {
      maxDrops = 64 - maxRaindropsPerLevel;
      val = 0;
  }
  while (n < maxDrops) {
    int x = random(0,8), y = random(0,8);
    if (level[x][y] != val) {
      level[x][y] = val;
      n++;
      } else {
        level[x][y] = 1 - val;
      }
    }
  
  // Step 2: Compare new level with level 1 & remove continous rain drops
  for (int i=0; i<8; i++) {
    byte val = raindrops[i];
    byte val_d = 0x80;
    int j = 7;
    while (val != 0) {
      if (val >= val_d) {
        val -= val_d;
        level[i][j] = 0;  // Remove continous rain drop
        }
        val_d /= 0x2;
        j--;
      }
    }
    
  // Step 3: update rain
  for (int i=63; i >=8; i--) {
    raindrops[i] = raindrops[i-8];
    }
    
  for (int i=0; i<8; i++) {
    raindrops[i] = 0;
    for (int j=7; j>=0;j--) {
      raindrops[i] = raindrops[i]*2 + level[i][j];
      }
    }

  Serial.write(0xF2);
  for (int i=0; i<64; i++) {
    Serial.write(raindrops[i]);
  }
  delay(rainDelay);
}
